\chapter{Derivasi Matematis}
\section{Tight Binding Model}
\label{sec:tbmodel}
Derivasi pada bagian ini mengikuti \parencite{mitocw2019tightbinding}
\par 
Persamaan Schrodinger untuk potensial \textit{single atom}:$U(r)$
\begin{align}
    \left[\frac{p^2}{2m} + U(r) \right]\phi(r)=E_0 \phi(r)
    \\ \phi^*(r)\left[\frac{p^2}{2m} + U(r) \right]\phi(r)=\phi^*(r)E_0\phi(r)
\end{align}
Dengan menambahkan pengaruh dari atom lain:
\begin{align}
    \psi_k(r)=\sum_j b_k(r_j) \phi_k(r-r_j) \\
    \psi(r+R_l)=e^{ik.R_l}\psi(r), && (Teori && Bloch)\\
    \sum_j b_k(r_j) \phi(r-r_j+R_l)=e^{ik.R_l}\sum_j b_k(r_j) \phi(r-r_j)
\end{align}
Dengan mengsubtitusi $R_p=r_j-R_l$
\begin{align}
    b_k(R_p+R_l)=e^{ik.R_l}b_k(R_p)
\\  b_k(R_l)=e^{ik.R_l}b_k(0)\\
 b_k(r_j)=e^{ik.r_j}b_k(0)
\end{align}
Normalisasi Fungsi Gelombang:
\begin{align}
    \int{d^3r\psi^*_k(\textbf{r})\psi_k(\textbf{r})}=1\\
    1=\sum_{r_j}b_k^*(r_j) \sum_{R_l}b_k^*(R_l)\int d^3r\phi^*_k(r-r_j)\phi_k(r-R_l)\\
    1=b_k^*(0)b_k(0)\sum_{r_j}e^{ik.r_j}\sum_{R_l}e^{ik.R_l}\int d^3r\phi^*_k(r-r_j)\phi_k(r-R_l)\\
    1=Nb_k^*(0)b_k(0)\sum_{R_p}e^{-ik.R_p}\int d^3r\phi^*_k(r-R_p)\phi_k(r)\\
    \left[1=Nb_k^*(0)b_k(0)\sum_{R_p}e^{-ik.R_p}\int d^3r\phi^*_k(r-R_p)\phi_k(r)\right]^*\\
    1=Nb_k^*(0)b_k(0)\sum_{R_p}e^{ik.R_p}\int d^3r\phi^*_k(r)\phi_k(r-R_p)
    \\
    b_k^*(0)b_k(0)=\frac{1}{N}.\frac{1}{1+\sum_{R_p}e^{ik.R_p}\alpha_k(R_p)}
    \\ b_k(0) \approx \frac{1}{\sqrt{N}}
    \\ \psi_k(r)=\frac{1}{\sqrt{N}}\sum_j e^{ik.r_j} \phi_k(r-r_j)
\end{align}
Maka \textit{first order correction} dari energi:
\begin{align}
    \psi_k^*(r)H\psi_k=\frac{1}{N}\sum_j \sum_m e^{ik.(r_j-r_m)}\int\phi^*(r-r_m)H\phi(r-r_j)dr
    \\ \psi_k^*(r)H\psi_k= \sum_n e^{-ik.\rho(n)}\int\phi^*(r)H\phi(r - r_j)
\end{align}
Misal $\gamma = \phi^*(r)H\phi(r - r_j) $, dan basis orbital lokal $|f_n \rangle = | \phi_a (r - r_j) \rangle$ maka Hamiltonian Tight Binding dapat kita modelkan sebagai
\begin{align}
  H = E_0 \sum_n |f_n \rangle \langle f_n | + \gamma \sum_n [|f_n \rangle \langle f_{n+1} | + |f_{n+1}\rangle \langle f_n | ] \\ 
  H = \sum_n a_n |f_n \rangle \langle f_n | +  \sum_n b_{n+1} [|f_n \rangle \langle f_{n+1} | + |f_{n+1}\rangle \langle f_n | ] \\ 
\end{align}

\section{Operator Kreasi dan Anihilasi}
Derivasi mengikuti \parencite{adams2014quantum}

Hamiltonian osilator harmonik kuantum satu dimensi:
\begin{align}
H = \frac{p^2}{2m} + \frac{1}{2}m\omega^2 x^2
\end{align}
Faktorisasi persamaan Hamiltonian dengan mendefinisikan operator a dan a†:
\begin{align}
a &= \sqrt{\frac{m\omega}{2\hbar}} \left( x + \frac{i}{m\omega} p \right) \
a^\dagger &= \sqrt{\frac{m\omega}{2\hbar}} \left( x - \frac{i}{m\omega} p \right)
\end{align}
Komutator dari operator a dan a† dengan relasi [x,p]=iℏ:
\begin{align}
[a, a^\dagger] &= \frac{m\omega}{2\hbar} \left[ x + \frac{i}{m\omega} p, x - \frac{i}{m\omega} p \right] \\
[a, a^\dagger] &= \frac{m\omega}{2\hbar} \left( -\frac{i}{m\omega}[x,p] + \frac{i}{m\omega}[p,x] \right) \\
[a, a^\dagger] &= \frac{m\omega}{2\hbar} \left( -\frac{i}{m\omega}(i\hbar) + \frac{i}{m\omega}(-i\hbar) \right) \\
[a, a^\dagger] &= \frac{m\omega}{2\hbar} \left( \frac{\hbar}{m\omega} + \frac{\hbar}{m\omega} \right) = 1
\end{align}
Substitusi perkalian operator ke dalam Hamiltonian:
\begin{align}
a^\dagger a &= \frac{m\omega}{2\hbar} \left( x - \frac{i}{m\omega} p \right) \left( x + \frac{i}{m\omega} p \right) \\
a^\dagger a &= \frac{m\omega}{2\hbar} \left( x^2 + \frac{p^2}{m^2\omega^2} + \frac{i}{m\omega}[x,p] \right) \\
a^\dagger a &= \frac{m\omega}{2\hbar} x^2 + \frac{p^2}{2m\hbar\omega} - \frac{1}{2} \\
\hbar\omega \left( a^\dagger a + \frac{1}{2} \right) &= \frac{p^2}{2m} + \frac{1}{2}m\omega^2 x^2
\end{align}
Hamiltonian dalam bentuk operator jumlah partikel N=a†a:
\begin{align}
H = \hbar\omega \left( a^\dagger a + \frac{1}{2} \right)
\end{align}
Komutator Hamiltonian terhadap operator a dan a†:
\begin{align}
[H, a] &= \hbar\omega [a^\dagger a, a] = -\hbar\omega a \
[H, a^\dagger] &= \hbar\omega [a^\dagger a, a^\dagger] = \hbar\omega a^\dagger
\end{align}

Aplikasi operator pada nilai eigen energi H∣n⟩=En​∣n⟩:
\begin{align}
H (a^\dagger |n\rangle) &= (E_n + \hbar\omega) (a^\dagger |n\rangle) \
H (a |n\rangle) &= (E_n - \hbar\omega) (a |n\rangle)
\end{align}
Aksi operator kreasi (menciptakan partikel/eksitasi) dan anihilasi (memusnahkan):
\begin{align}
a^\dagger |n\rangle &= \sqrt{n+1} |n+1\rangle \
a |n\rangle &= \sqrt{n} |n-1\rangle
\end{align}
Dari operator ini kita dapat menuliskan kembali model Tight-Binding \ref{sec:tbmodel},
\[
\begin{aligned}
  H =\sum_i \epsilon a^{\dagger}_{i} a_{i} -t \sum_{\langle i,j \rangle} \left( a^{\dagger}_{i} a_{j} + \text{H.c.} \right) 
    \end{aligned}
\]

\section{Derivasi Fase Berry, Koneksi Berry, dan Kelengkungan Berry}

Derivasi berikut mengikuti langkah-langkah pada video \parencite{profnano2025berry}

Misalkan Hamiltonian $H(R)$ berevolusi secara adiabatik, maka;
\begin{equation}
  H(\bar{R}(t)) = H(r_1(t), r_2(t), ...)
\end{equation}
Persamaan Schrodinger bergantung waktu;
\begin{align}
  H|\psi(t)\rangle = i \hbar \frac{\partial}{\partial t}|\psi(t)\rangle  \\
  |\psi(t)\rangle = \sum_n e^{-iE_nt/\hbar} |n\rangle \qquad ; \qquad H|n \rangle = E_n|n\rangle \\ 
  |\psi(t)\rangle = e^{-iE_nt/\hbar} |n \rangle
\end{align}
Kembali kepada hamiltonian $H(R)$
\begin{align}
  H(\bar{R}(t))|\psi(t)\rangle = i\hbar \frac{\partial}{\partial t} |\psi(t)\rangle  \\ 
  H(\bar{R}(t))|n, \bar{R}(t)\rangle = E_n(\bar{R}(t)) |n, \bar{R}(t)\rangle \\ 
    t = 0 \rightarrow |\psi(0) \rangle = |n, \bar{R}(0) \rangle
\end{align}
Apabila kita asumsikan bahwa solusi dari sistem ini hanya terdiri dari fase dinamis, maka:
\begin{equation}
  |\psi(t)\rangle = \exp \left[ -\frac{i}{\hbar} \int_0^t E_n (\bar{R}(s))ds \right] |n, \bar{R}(t) \rangle 
\end{equation}
subtitusi,
\begin{align}
  i\hbar \frac{\partial}{\partial t}|\psi(t)\rangle = E_n \left( \vec{R}(t) \right) \exp \left[ -\frac{i}{\hbar} \int_{0}^{t} E_n (\vec{R}(s)) ds \right] |n, \vec{R}(t) \rangle \\ 
  + \exp \left[ -\frac{i}{\hbar} \int_{0}^{t} E_n (\vec{R}(s)) ds \right] i\hbar \frac{\partial}{\partial t} |n, \vec{R}(t) \rangle \\ 
  = E_n \left( \vec{R}(t) \right) \exp \left[ -\frac{i}{\hbar} \int_{0}^{t} E_n (\vec{R}(s)) ds \right] |n, \vec{R}(t) \rangle \\ 
   + \exp \left[ -\frac{i}{\hbar} \int_{0}^{t} E_n (\vec{R}(s)) ds \right] i\hbar \dot{\vec{R}}(t) \frac{\partial}{\partial \vec{R}} |n, \vec{R}(t) \rangle \\ 
   i\hbar \frac{\partial}{\partial t}|\psi(t)\rangle = H(\vec{R}(t)) |\psi(t) \rangle \\ 
  + \exp \left[ -\frac{i}{\hbar} \int_{0}^{t} E_n (\vec{R}(s)) ds \right] i\hbar \dot{\vec{R}}(t) \frac{\partial}{\partial \vec{R}} |n, \vec{R}(t) \rangle  
\end{align}
$ i\hbar \dot{\vec{R}}(t) \frac{\partial}{\partial \vec{R}} |n, \vec{R}(t) \rangle $ harus nol untuk memenuhi persamaan Schrodinger. Untuk itu kita memerlukan tambahan fase pada solusi tebakan;
\begin{align}
  |\psi(t)\rangle = \exp[i\gamma_n(t)] \exp \left[ -\frac{i}{\hbar} \int_0^t E_n (\bar{R}(s))ds \right] |n, \bar{R}(t) \rangle  \\ 
i\hbar \frac{\partial}{\partial t} |\Psi(t) \rangle = -\hbar \frac{d\gamma_n(t)}{dt} |\Psi(t) \rangle + E_n \left( \vec{R}(t) \right) |\Psi(t) \rangle \\
+ \exp \left[ i\gamma_n(t) - \frac{i}{\hbar} \int_{0}^{t} E_n (\vec{R}(s)) ds \right] i\hbar \frac{\partial}{\partial t} |n, \vec{R}(t) \rangle \\ 
\end{align}  
Untuk memenuhi persamaan Schrodinger,$ -\hbar \frac{d\gamma_n(t)}{dt} |\Psi(t) \rangle$ dan $ \exp \left[ i\gamma_n(t) - \frac{i}{\hbar} \int_{0}^{t} E_n (\vec{R}(s)) ds \right] i\hbar \frac{\partial}{\partial t} |n, \vec{R}(t) \rangle $ harus menjadi nol.


\begin{align}
    -\hbar \frac{d\gamma_n(t)}{dt} |\Psi(t) \rangle &= \exp \left[ i\gamma_n(t) - \frac{i}{\hbar} \int_{0}^{t} E_n (\vec{R}(s)) ds \right] i\hbar \frac{\partial}{\partial t} |n, \vec{R}(t) \rangle \\ 
    -\hbar \frac{d\gamma_n(t)}{dt} |\Psi(t) \rangle &= \exp \left[ i\gamma_n(t) - \frac{i}{\hbar} \int_{0}^{t} E_n (\vec{R}(s)) ds \right] i\hbar \dot{\vec{R}} \cdot \nabla_{\vec{R}} |n, \vec{R}(t) \rangle \\ 
    \frac{d\gamma_n(t)}{dt} |n, \vec{R}(t) \rangle &= i \dot{\vec{R}} \cdot \nabla_{\vec{R}} |n, \vec{R}(t) \rangle \\ 
    \frac{d\gamma_n(t)}{dt} \langle n, \vec{R}(t)|n, \vec{R}(t) \rangle &= i \dot{\vec{R}} \cdot \langle n, \vec{R}(t)| \nabla_{\vec{R}} |n, \vec{R}(t) \rangle \\
    \frac{d\gamma_n(t)}{dt} &= i \dot{\vec{R}} \cdot \langle n, \vec{R}(t)| \nabla_{\vec{R}} |n, \vec{R}(t) \rangle \\ 
    \gamma_n(t) &= i \int_0^t ds \quad \dot{\vec{R}}(s)\langle n, \vec{R}(s)| \nabla_{\vec{R}} |n, \vec{R}(s) \rangle \\ 
                &= i \int_{\vec{R_1}}^{\vec{R_2}} d\vec{R} \; \langle n, \vec{R}| \nabla_{\vec{R}} |n, \vec{R} \rangle
  \end{align}
Fase Berry $\gamma_n$ harus real untuk memenuhi konversasi probabilitas gelombang.

\begin{align}
\gamma_n &= \int_{\vec{R}_1}^{\vec{R}_2} d\vec{R} \cdot i \langle n, \vec{R} | \nabla_{\vec{R}} | n, \vec{R} \rangle \\
&= \int_{s_1}^{s_2} ds \frac{d\vec{R}(s)}{ds} \cdot i \langle n, \vec{R} | \nabla_{\vec{R}} | n, \vec{R} \rangle \\
&\text{Fakta bahwa: } \frac{d}{ds} | n, \vec{R}(s) \rangle = \left( \nabla_{\vec{R}} | n, \vec{R} \rangle \right) \cdot \frac{d\vec{R}(s)}{ds} \\
\gamma_n &= \int_{s_1}^{s_2} ds \, i \left\langle n, \vec{R} \right| \frac{d}{ds} \left| n, \vec{R} \right\rangle
\end{align}

\fbox{$\langle n, \vec{R} | n, \vec{R} \rangle = 1$} \quad 
\fbox{$\frac{d}{ds} \langle n, \vec{R} | n, \vec{R} \rangle = 0$} \quad 
\fbox{$\frac{d}{ds} \langle n, \vec{R} | = \left( \frac{d}{ds} | n, \vec{R} \rangle \right)^\dagger$}

\begin{align*}
\frac{d}{ds} \langle n, \vec{R}(s) | n, \vec{R}(s) \rangle &= \frac{d}{ds} \langle n, \vec{R} | | n, \vec{R} \rangle + \langle n, \vec{R} | \frac{d}{ds} | n, \vec{R} \rangle \\
&= 2\text{Re} \left[ \langle n, \vec{R} | \frac{d}{ds} | n, \vec{R} \rangle \right] \\ 
&= 0
\end{align*}
Karena $\langle n, \vec{R} | \frac{d}{ds} | n, \vec{R} \rangle$ sama dengan 0, maka fase berry $\gamma_n$ harus real
\par 
Isi integral dari fase berry disebut koneksi Berry $\vec{A}_n(\vec{R})$ yang dapat dipandang sebagai sebuah medan vector.
\begin{equation}
  A_{n, \mu}(\vec{R}) = i \langle n, \vec{R} | \frac{\partial}{\partial r_\mu} | n, \vec{R} \rangle
\end{equation}

Misal koneksi Berry diberikan sebagai $\vec{A_n}(k) = i \langle n_{\vec{k}} | \nabla | n_{\vec{k}} \rangle$ dan mengaplikasikan projector $\hat{P}_{\vec{k}} = | n_{\vec{k}} \rangle \langle n_{\vec{k}} |$

\fbox{$\vec{A}_n(\vec{k}) = i \text{Tr} [\hat{P}_{\vec{k}} \nabla_{\vec{k}} \hat{P}_{\vec{k}}]$} \quad 
\fbox{$\hat{P}_{\vec{k}} = | n_{\vec{k}} \rangle \langle n_{\vec{k}} |$}

\begin{align*}
\gamma_n &= \int_{\vec{k}_1}^{\vec{k}_2} \vec{A}_n(\vec{k}) \cdot d\vec{k} \approx \sum_{j=0}^{N-1} \vec{A}_n(\vec{k}_j) \cdot d\vec{k}_j = i \sum_{j=0}^{N-1} \text{Tr} [\hat{P}_{\vec{k}_j} \nabla_{\vec{k}} \hat{P}_{\vec{k}_j}] \cdot d\vec{k}_j \\
&= i \sum_{j=0}^{N-1} \text{Tr} [\hat{P}_{\vec{k}_j} (\nabla_{\vec{k}} \hat{P}_{\vec{k}_j}) \cdot d\vec{k}_j] \approx i \sum_{j=0}^{N-1} \text{Tr} [\hat{P}_{\vec{k}_j} (\hat{P}_{\vec{k}_{j+1}} - \hat{P}_{\vec{k}_j})] \\
&= i \sum_{j=0}^{N-1} \langle n_{\vec{k}_j} | n_{\vec{k}_{j+1}} \rangle - 1
\end{align*}

\begin{center}
    \textcolor{red}{\textbf{Parallel transport}} \\
    \colorbox{yellow!20}{
        $\displaystyle \langle n_{\vec{k}_j} | n_{\vec{k}_{j+1}} \rangle = 1 - i \vec{A}_n(\vec{k}_j) \cdot d\vec{k}_j$
    }
\end{center}
\par 
Koneksi Berry $A_n(k)$ bersifat gauge-dependent, dimana transormasinya menghasilkan suku gradient fase $\nabla_k \phi (k)$$\vec{A}_n(\vec{k}) \xrightarrow{\text{Gauge}} \vec{A}_n(\vec{k}) + \nabla_{\vec{k}} \phi(k)$. Untuk itu, kelengkungan Berry diberikan untuk memberikan parameter yang gauge-invariant.
\begin{align*}
\vec{\Omega}_n(\vec{k}) &\equiv \nabla \times \vec{A}_n(\vec{k}) \\
\vec{\Omega}_n(\vec{k}) &\xrightarrow{\text{Gauge}} \vec{\Omega}_n(\vec{k})
\end{align*}

\section{Formulasi Wannier Center}
Derivas berikut berlandaskan dari sumber; \parencite{vanderbilt2021theory} \parencite{Vanderbilt2018}
\subsection*{Bloch State}

\begin{align}
\psi_{n\mathbf{k}}(\mathbf{r})
&=
e^{i\mathbf{k}\cdot\mathbf{r}}
u_{n\mathbf{k}}(\mathbf{r}) \\
u_{n\mathbf{k}}(\mathbf{r}+\mathbf{R})
&=
u_{n\mathbf{k}}(\mathbf{r})
\end{align}

Normalisasi:
\begin{align}
\langle \psi_{n\mathbf{k}'} | \psi_{n\mathbf{k}} \rangle
=
\frac{(2\pi)^3}{V}
\delta(\mathbf{k}-\mathbf{k}')
\end{align}

\subsection*{Definisi Wannier Function}

\begin{align}
| w_{n0} \rangle
=
\frac{V}{(2\pi)^3}
\int_{\text{BZ}} d^3k \,
| \psi_{n\mathbf{k}} \rangle
\end{align}

Substitusi bentuk Bloch:

\begin{align}
| w_{n0} \rangle
=
\frac{V}{(2\pi)^3}
\int_{\text{BZ}} d^3k \,
e^{i\mathbf{k}\cdot\mathbf{r}}
| u_{n\mathbf{k}} \rangle
\end{align}

\subsection*{Identitas Operator Posisi}

\begin{align}
\mathbf{r} e^{i\mathbf{k}\cdot\mathbf{r}}
=
i \nabla_{\mathbf{k}} e^{i\mathbf{k}\cdot\mathbf{r}}
\end{align}

\subsection*{Aksi Operator Posisi}

\begin{align}
\mathbf{r}
| w_{n0} \rangle
&=
\frac{V}{(2\pi)^3}
\int_{\text{BZ}} d^3k \,
\mathbf{r}
e^{i\mathbf{k}\cdot\mathbf{r}}
| u_{n\mathbf{k}} \rangle \\
&=
i
\frac{V}{(2\pi)^3}
\int_{\text{BZ}} d^3k \,
\nabla_{\mathbf{k}}
\left(
e^{i\mathbf{k}\cdot\mathbf{r}}
\right)
| u_{n\mathbf{k}} \rangle
\end{align}

Integrasi parsial di ruang $\mathbf{k}$:

\begin{align}
&=
i
\frac{V}{(2\pi)^3}
\int_{\text{BZ}} d^3k \,
\nabla_{\mathbf{k}}
\left(
e^{i\mathbf{k}\cdot\mathbf{r}}
| u_{n\mathbf{k}} \rangle
\right) \\
&\quad
-
i
\frac{V}{(2\pi)^3}
\int_{\text{BZ}} d^3k \,
e^{i\mathbf{k}\cdot\mathbf{r}}
\nabla_{\mathbf{k}}
| u_{n\mathbf{k}} \rangle
\end{align}

Dengan periodisitas pada batas BZ, suku permukaan hilang:

\begin{align}
\mathbf{r}
| w_{n0} \rangle
=
i
\frac{V}{(2\pi)^3}
\int_{\text{BZ}} d^3k \,
e^{i\mathbf{k}\cdot\mathbf{r}}
\nabla_{\mathbf{k}}
| u_{n\mathbf{k}} \rangle
\end{align}

\subsection*{Ekspektasi Nilai Posisi}

\begin{align}
\langle w_{n0} |
\mathbf{r}
| w_{n0} \rangle
&=
i
\left(
\frac{V}{(2\pi)^3}
\right)^2
\int_{\text{BZ}} d^3k
\int_{\text{BZ}} d^3k'
\,
\langle u_{n\mathbf{k}'} |
e^{-i\mathbf{k}'\cdot\mathbf{r}}
e^{i\mathbf{k}\cdot\mathbf{r}}
\nabla_{\mathbf{k}}
| u_{n\mathbf{k}} \rangle
\end{align}

Gunakan ortogonalitas Bloch state:

\begin{align}
\langle \psi_{n\mathbf{k}'} | \psi_{n\mathbf{k}} \rangle
=
\frac{(2\pi)^3}{V}
\delta(\mathbf{k}-\mathbf{k}')
\end{align}

Sehingga diperoleh:

\begin{align}
\langle w_{n0} |
\mathbf{r}
| w_{n0} \rangle
=
i
\frac{V}{(2\pi)^3}
\int_{\text{BZ}} d^3k \,
\langle u_{n\mathbf{k}} |
\nabla_{\mathbf{k}}
u_{n\mathbf{k}} \rangle
\end{align}

\subsection*{Definisi Berry Connection}

\begin{align}
\mathbf{A}_n(\mathbf{k})
=
i
\langle u_{n\mathbf{k}} |
\nabla_{\mathbf{k}}
u_{n\mathbf{k}} \rangle
\end{align}

\subsection*{Hasil Akhir}

\begin{align}
\boxed{
\mathbf{r}_n
=
\langle w_{n0} |
\mathbf{r}
| w_{n0} \rangle
=
\frac{V}{(2\pi)^3}
\int_{\text{BZ}}
d^3k \,
\mathbf{A}_n(\mathbf{k})
}
\end{align}

\chapter{Lampiran Kode Program}
\label{app:kode-program}
\section{Kode Utama Simulasi(Model Kane-Mele 3D)}
Berikut adalah kode utama yang memodelkan sistem yang kita teliti dalam lingkungan PyhTB, dijadikan sebagai fungsi model yang dipanggil pada kode-kode analisis berikutnya:

\begin{lstlisting}[language=Python, caption={Model Stacking Graphene}, label={lst:model-stacking}]
from pythtb import TBModel, Lattice
import numpy as np

def set_model(t, soc, rashba, delta, W):
    sigma_z = np.array([0., 0., 0., 1.])
    sigma_x = np.array([0., 1., 0., 0])
    sigma_y = np.array([0., 0., 1., 0])

    r3h = np.sqrt(3.0) / 2.0
    sigma_a = 0.5 * sigma_x - r3h * sigma_y
    sigma_b = 0.5 * sigma_x + r3h * sigma_y
    sigma_c = -1.0 * sigma_x

    lat = [[1, 0, 0], [0.5, np.sqrt(3.0)/2.0, 0.0], [0.0, 0.0, 1.0]]
    orb = [[1./3., 1./3., 0.0], [2./3., 2./3., 0.0]]
    lattice = Lattice(lat_vecs=lat, orb_vecs=orb, periodic_dirs=...)
    model = TBModel(lattice=lattice, spinful=True)

    disorder_values = np.random.uniform(-W/2, W/2, size=len(orb))
    onsite_energies = [
        delta + disorder_values[i] if i % 2 == 0 else -delta + disorder_values[i]

        for i in range(len(orb))
    ]
    model.set_onsite(onsite_energies)

    # Hopping terms

    for lvec in ([0, 0, 0], [-1, 0, 0], [0, -1, 0]):
        model.set_hop(t, 0, 1, lvec)

    for lvec in ([1, 0, 0], [-1, 1, 0], [0, -1, 0]):

        model.set_hop(soc * 1.j * sigma_z, 0, 0, lvec)

    for lvec in ([-1, 0, 0], [1, -1, 0], [0, 1, 0]):

        model.set_hop(soc * 1.j * sigma_z, 1, 1, lvec)

    model.set_hop(0.1 * soc * 1j * sigma_z, 1, 1, [0, 0, 1])
    model.set_hop(-0.1 * soc * 1j * sigma_z, 0, 0, [0, 0, 1])

    model.set_hop(1.j * rashba * sigma_a, 0, 1, [0, 0, 0], mode="add")
    model.set_hop(1.j * rashba * sigma_b, 0, 1, [-1, 0, 0], mode="add")
    model.set_hop(1.j * rashba * sigma_c, 0, 1, [0, -1, 0], mode="add")

    return model

model = set_model(1.0, 0.3, 0.1, 1.0, 0.0)
model.info()
\end{lstlisting}

\section{Kode Validasi Model}
Berikut adalah kode yang kami gunakan untuk memvalidasi model:

\begin{lstlisting}[language=Python, caption={Visualisasi Kristal}, label={lst:vis-model}]

from pythtb import TBModel, Lattice
import numpy as np
import matplotlib
matplotlib.use('TkAgg')
import matplotlib.pyplot as plt
import plotly.express as px
from HamiltonianModel.hamiltonian import set_model

delta = 0.0
t = 1.0
soc_list = np.array([0.06, 0.24])
soc_val = 0.125
rashba = 0.05
W = 0 * soc_list

# Matriks Pauli
sigma_z = np.array([0., 0., 0., 1.])
sigma_x = np.array([0., 1., 0., 0])
sigma_y = np.array([0., 0., 1., 0])
r3h = np.sqrt(3.0) / 2.0
sigma_a = 0.5 * sigma_x - r3h * sigma_y
sigma_b = 0.5 * sigma_x + r3h * sigma_y
sigma_c = -1.0 * sigma_x

data_csv =[]
my_model = set_model(t, soc_val, rashba, delta, 0)

print(my_model)
my_model.info()

sc_model = my_model.make_supercell([[2, 1, 0], [-1, 2, 0], [0, 0, 2]], to_home=True)
slab_model = sc_model.cut_piece(3,1, glue_edges=False)
pos = slab_model.get_orb_vecs()
z_vals = pos[:,2]
z_unique = np.unique(np.round(z_vals, 5))
colors_layer = ["red", "green", "blue", "orange", "purple"]
color_site = []

for z in z_vals:
    idx = np.where(z_unique == np.round(z,5))[0][0]
    color_site.append(colors_layer[idx % len(colors_layer)])

fig = slab_model.visualize_3d(show_model_info=False, site_colors=color_site)

k_nodes = [[0, 0], [2 / 3, 1 / 3], [0.5, 0.5], [1 / 3, 2 / 3], [0, 0], [0.5, 0.5]]
k_label = (r"$\Gamma $", r"$K$", r"$M$", r"$K^\prime$", r"$\Gamma $", r"$M$")
fig, ax = slab_model.plot_bands(
        nk=500, k_nodes=k_nodes, k_node_labels=k_label, proj_orb_idx=[0], lw=1
       )
fig.show()

\end{lstlisting}

\begin{lstlisting}[language=Python, caption={Validasi \textit{Edge State}}, label={lst:vis-model}]

from pythtb import TBModel, Lattice
import numpy as np
import matplotlib
matplotlib.use('TkAgg')
import matplotlib.pyplot as plt
from HamiltonianModel.hamiltonian import set_model
delta = 0.0
t = 1.0
soc_val = 0.1
rashba = 0.1
W = 0 * soc_val

# Matriks Pauli

sigma_z = np.array([0., 0., 0., 1.])
sigma_x = np.array([0., 1., 0., 0])
sigma_y = np.array([0., 0., 1., 0])

r3h = np.sqrt(3.0) / 2.0

sigma_a = 0.5 * sigma_x - r3h * sigma_y
sigma_b = 0.5 * sigma_x + r3h * sigma_y
sigma_c = -1.0 * sigma_x

my_model = set_model(t, soc_val, rashba, delta, W)
print(my_model)
my_model.info()

fin_model = my_model.make_finite(periodic_dirs=[1], num_cells=[20])

k_nodes = [
    [0.0, 0.0],  # Gamma
    [0.5, 0.0],  # Mx
    [0.5, 0.5],  # Lx
    [0.0, 0.5],  # A
    [0.0, 0.0]   # Gamma
]
k_labels = (r"$\Gamma $",r"$M_x$", r"$L_x$", r"$A$", r"$\Gamma $")

#fin_model.visualize_3d(draw_hoppings=True)

fig, ax = fin_model.plot_bands(
    nk=500, k_nodes=k_nodes, k_node_labels=k_labels, proj_orb_idx=[1]
)
plt.savefig('result/ribbon_band.pdf')
plt.show()

\end{lstlisting}

\section{Kode Peta Variasi Parameter}
Berikut adalah kode yang kami gunakan untuk menunjukkan pengaruh variasi parameter lewat peta spektrum, peta probabilitas, dan peta kerapatan energi:

\begin{lstlisting}[language=Python, caption={Konstruksi Peta Spektrum}, label={lst:peta-spektrum}]

from pythtb import TBModel, Lattice
import numpy as np
import matplotlib
matplotlib.use('TkAgg')
import matplotlib.pyplot as plt
from HamiltonianModel.hamiltonian import set_model

delta = np.array([0.0, 0.5, 1.0, 1.5, 2.0])
t = 1.0
soc_val = 0.25
rashba =  np.array([0.0, 0.05, 0.1, 0.2 , 0.3])
W = 0 * soc_val

# Matriks Pauli
sigma_z = np.array([0., 0., 0., 1.])
sigma_x = np.array([0., 1., 0., 0])
sigma_y = np.array([0., 0., 1., 0])
r3h = np.sqrt(3.0) / 2.0
sigma_a = 0.5 * sigma_x - r3h * sigma_y
sigma_b = 0.5 * sigma_x + r3h * sigma_y
sigma_c = -1.0 * sigma_x


k_nodes = [[0, 0], [0.5, 0], [0.5, 0.5], [0, 0], [0, 0.5]]
k_labels = [
    r"$\bar{\Gamma}$",
    r"$\bar{X}$",
    r"$\bar{M}$",
    r"$\bar{\Gamma}$",
    r"$\bar{Y}$",
]

fig, ax = plt.subplots(len(delta), len(rashba), figsize=(12,12))
ax = np.atleast_2d(ax)

for a,i in enumerate(delta):
    for b,j in enumerate(rashba):

        my_model = set_model(t, soc_val, j, i, W)
        fin_model = my_model.make_finite(periodic_dirs=[0], num_cells=[20])

        # buat figure sementara
        fig_tmp, ax_tmp = fin_model.plot_bands(
            nk=201,
            k_nodes=k_nodes,
            k_node_labels=k_labels,
            lw=1
            )

        # ambil axes tunggal
        if isinstance(ax_tmp, (list, tuple, np.ndarray)):
            ax_tmp = np.asarray(ax_tmp).ravel()[0]

        # copy semua garis
        for line in ax_tmp.get_lines():
            ax[a,b].plot(
                line.get_xdata(),
                line.get_ydata(),
                color=line.get_color(),
                lw=line.get_linewidth()
            )

        ax[a,b].set_title(f"Δ={i}, R={j}")
        ax[a,b].set_xlim(ax_tmp.get_xlim())
        ax[a,b].set_ylim(ax_tmp.get_ylim())

        plt.close(fig_tmp)   

plt.tight_layout()
plt.savefig("result/peta_ribbon.pdf")
plt.show()

\end{lstlisting}

\begin{lstlisting}[language=Python, caption={Konstruksi Peta Probabilitas Elektron Pada Struktur Pita}, label={lst:peta-prob}]

from pythtb import TBModel, Lattice
import numpy as np
import matplotlib
matplotlib.use('TkAgg')
import matplotlib.pyplot as plt
from HamiltonianModel.hamiltonian import set_model as sm

delta = np.array([0.0, 0.5, 1.0, 2.5, 3.0])
t = 1.0
soc_val = 0.25
rashba = np.array([0.0, 0.5, 1.0, 2.5, 3.0])

fig, ax = plt.subplots(5, 5, figsize=(12, 5))

k_nodes = [
    [0.0, 0.0, 0.0],    # Gamma
    [2./3., 1./3., 0.0],# K
    [0.5, 0.5, 0.0],    # M
    [1./3., 2./3., 0.0],# K'
    [0.0, 0.0, 0.0],    # Gamma
]
label_k = (r"$\Gamma$", r"$K$", r"$M$", r"$K^\prime$", r"$\Gamma$")

for i, d in enumerate(delta):
    for j, r in enumerate(rashba):
        my_model = sm(t, soc_val, r, d, 0)

        my_model.plot_bands(
            k_nodes=k_nodes,
            nk=201,
            k_node_labels=label_k,
            fig=fig,
            ax=ax[i, j],
            proj_orb_idx=[0],
            proj_spin=True,
            cmap='inferno',
            cbar=True
        )

for i in range(5):
    for j in range(5):
        ax[i, j].grid(True, alpha=0.3)

        # Hanya baris terakhir yang punya label k
        if i != 4:
            ax[i, j].set_xticklabels([])
            ax[i, j].set_xlabel("")
        
        # Hanya kolom pertama yang punya label energi
        if j != 0:
            ax[i, j].set_yticklabels([])
            ax[i, j].set_ylabel("")

        # Judul kecil tiap panel
        ax[i, j].set_title(
            rf"$\delta={delta[i]}$, $\lambda_R={rashba[j]}$",
            fontsize=8
        )

# Label global
fig.text(0.5, 0.04, "k-path", ha='center', fontsize=12)
fig.text(0.04, 0.5, "Energy", va='center', rotation='vertical', fontsize=12)

# Spasi antar subplot (lebih rapi dari tight_layout)
plt.subplots_adjust(
    left=0.08,
    right=0.98,
    bottom=0.08,
    top=0.95,
    wspace=0.25,
    hspace=0.35
)


plt.tight_layout()
plt.savefig('result/peta_bulk.pdf', dpi=600)
plt.show()

\end{lstlisting}

\begin{lstlisting}[language=Python, caption={Konstruksi Peta Kerapatan Energi}, label={lst:peta-DOS}]

\end{lstlisting}

\section{Kode Analisis Topologi}
Berikut adalah kode yang kami gunakan untuk menganalisis sifat topologis grafena dalam pengaruh \textit{stacking layer}:

\begin{lstlisting}[language=Python, caption={Analisis Evolusi \textit{Hybrid Wannier Center}}, label={lst:hwc}]

from pythtb import WFArray, Mesh, Lattice, TBModel
import numpy as np 
import matplotlib.pyplot as plt 
from HamiltonianModel.hamiltonian import set_model as sm 

t = 1.0
soc = 0.3
rashba = 0.25
delta = 1.0 

model = sm(t, soc, rashba, delta, 0)

k_nodes = [
    [0.0, 0.0, 0.0],    # Gamma
    [2./3., 1./3., 0.0],# K
    [0.5, 0.5, 0.0],    # M
    [1./3., 2./3., 0.0],# K'
    [0.0, 0.0, 0.0],    # Gamma
]
label_k = (r"$\Gamma$", r"$K$", r"$M$", r"$K^\prime$", r"$\Gamma$")

#model.plot_bands(       k_nodes=k_nodes, nk=201, k_node_labels=label_k, proj_orb_idx=[0] )

mesh = Mesh(["k", "k", "k"])
mesh.build_grid(shape=(41, 41, 41), gamma_centered=True)
print(mesh)

wf_array = WFArray(model.lattice, mesh, spinful=True)
wf_array.solve_model(model=model)

wan_cent = wf_array.berry_phase(
        axis_idx=1, state_idx=[0,1], contin=True, berry_evals=True
        )
wan_cent /= 2 * np.pi

nky = wan_cent.shape[0]
ky = np.linspace(0, 1, nky)

flux = wf_array.berry_flux(plane=(0, 1), state_idx=[0,1], non_abelian=False)
chern_kz = np.sum(flux, axis=(0,1)) / (2 * np.pi)
print(chern_kz)
#print(wan_cent)

for shift in range(-2, 3):
    plt.plot(ky, wan_cent[:, 0] + float(shift), "k")
    plt.plot(ky, wan_cent[:, 1] + float(shift), "k")

plt.savefig("result/hwf.pdf")
plt.show()

\end{lstlisting}

\begin{lstlisting}[language=Python, caption={Analisis Plot Fungsi \textit{Axion Angle}}, label={lst:axion}]

from pythtb import TBModel, Lattice
import matplotlib.pyplot as plt
import numpy as np
from HamiltonianModel.hamiltonian import set_model as sm

sigma_z = np.array([0., 0., 0., 1.], dtype=complex)
sigma_x = np.array([0., 1., 0., 0], dtype=complex)
sigma_y = np.array([0., 0., 1., 0], dtype=complex)

r3h = np.sqrt(3.0) / 2.0
sigma_a = 0.5 * sigma_x - r3h * sigma_y
sigma_b = 0.5 * sigma_x + r3h * sigma_y
sigma_c = -1.0 * sigma_x

lat = [[1, 0, 0], [0.5, np.sqrt(3.0)/2.0, 0.0], [0.0, 0.0, 1.0]]
orb = [[1./3., 1./3., 0.0], [2./3., 2./3., 0.0]]
lattice = Lattice(lat_vecs=lat, orb_vecs=orb, periodic_dirs=...)

model = TBModel(lattice=lattice, spinful=True)

t = 1.0
soc = 1/4
m = 0.5
rashba = 0.05

model.set_onsite(
        lambda beta: [0, m * np.sin(beta), m * np.sin(beta), m * np.sin(beta)], ind_i=0,
        )
model.set_onsite(
        lambda beta: [0, -m * np.sin(beta), -m * np.sin(beta), -m * np.sin(beta)], ind_i=1,
        )

for lvec in ([-1, 0, 0], [0, -1, 0], [0, 0, -1]):
    model.set_hop(t, 0, 1, lvec)

model.set_hop(lambda beta: 3 * t + m * np.cos(beta), 0, 1, [0, 0, 0], mode="set")

lvec_list = ([1, 0, 0], [0, 1, 0], [0, 0, 1], [-1, 1, 0], [0, -1, 1], [1, 0, -1])
dir_list = ([0, 1, -1], [-1, 0, 1], [1, -1, 0], [1, 1, 0], [0, 1, 1], [1, 0, 1])

for j in range(6):
    spin = np.array([0.0] + dir_list[j])
    model.set_hop(1j * soc * spin, 0, 0, lvec_list[j])
    model.set_hop(-1j * soc * spin, 1, 1, lvec_list[j])

model.set_hop(1.j * rashba * spin, 0, 1, [0, 0, 0], mode="add")
model.set_hop(1.j * rashba * spin, 0, 1, [-1, 0, 0], mode="add")
model.set_hop(1.j * rashba * spin, 0, 1, [0, -1, 0], mode="add")

print(model)

nks = 30, 30, 30
n_beta = 21
betas = np.linspace(0, 2 * np.pi, n_beta, endpoint=True)
param_periods = {"beta": 2 * np.pi}

print(f"Total number of points: {nks[0] * nks[1] * nks[2] * n_beta}")

betas, axion, c2 = model.axion_angle(
    nks=nks,
    param_periods=param_periods,
    return_second_chern=True,
    use_tensorflow=True,
    diff_scheme="central",
    diff_order=8,
    beta=betas,
)

print(f"Second Chern number C2 = {c2}")

fig, ax = plt.subplots()

ax.set_xlabel(r"$\beta$", size=15)
ax.set_ylabel(r"$\theta$", size=15)

tick_positions = np.arange(0, 2 * np.pi + np.pi / 4, np.pi / 4)
tick_labels = [
    r"$0$",
    r"$\frac{\pi}{4}$",
    r"$\frac{\pi}{2}$",
    r"$\frac{3\pi}{4}$",
    r"$\pi$",
    r"$\frac{5\pi}{4}$",
    r"$\frac{6\pi}{4}$",
    r"$\frac{7\pi}{4}$",
    r"$2\pi$",
]

# Set the ticks and labels for both axes
ax.set_xticks(tick_positions)
ax.set_xticklabels(tick_labels)
ax.set_yticks(tick_positions)
ax.set_yticklabels(tick_labels)

## Riemann sum
ax.plot(betas, axion, lw=1, zorder=2, c="k")
ax.scatter(betas, axion, s=6, zorder=2, c="r")

ax.grid()
ax.set_title("Axion angle vs adiabatic parameter", size=12)
plt.savefig("result/axion_angle.pdf")
plt.show()

\end{lstlisting}
